# CHAPTER 3

- 데이터의 크기가 단일 물리 머신이 감당할 수 없게 커질때 여러 머신에 나누어 저장할 필요가 있다
    - 네트워크로 연결된 여러 스토리지를 분산 파일 시스템이라고 한다 (네트워크 기반인게 문제)
    - 하둡은 HDFS를 제공 (스트리밍 방식)

## 3.1 HDFS 설계

- HDFS의 설계 특성을 보자
    - 매우 큰 파일
        - 수백 메가 ~ 페타바이트
    - 스트리밍 방식의 데이터 접근
        - 한번 쓰고 여러번 읽기
        - 전체 데이터를 읽는 시간이 중요하다
            - 빠른 응답시간은 HBase를 사용하도록 하자
    - 범용 하드웨어 (별거 없는 하드웨어)
        - 머신 하나하나가 비싸고 신뢰도 높은 머신이 아니다
        - 충분히 얻을수 있는 머신들로 클러스터를 구성해도 문제 없다.

## 3.2 HDFS의 개념

### 3.2.1 블록

- 블록
    - 한번에 읽고 쓸수 있는 데이터의 최대량
    - HDFS는 특이하게 블록이 128MB로 크다
- 파일 시스템 vs HDFS
    - 파일시스템에서는 디스크 블록보다 작은 데이터가 들어와도 하나의 블록을 전체 차지하게 된다.
    - HDFS에서는 1MB의 작은 데이터가 들어온다고 해서 128MB의 블록을 모두 점유하는게 아니라 딱 1MB만 사용한다.
- 왜 HDFS 블록은 클까?
    - 탐색 비용을 최소화 하기 위함 (블록의 시작 offset을 찾기가 용이함)
- 블록을 사용하면 뭐가 좋을까?
    - 하나의 파일이 단일 머신을 점유할 확률은 없다.
        - 쪼개져서 퍼져서 저장되므로
        - 물론 하나에 다 몰릴게 할수도 있다
    - 스토리지의 서브시스템을 단순하게 만들 수 있다.
        - 장애 대응에 너무 중요하다
        - 권한과 같은 메타 데이터들은 블록에 저장하지 않고 별도의 시스템에 분리하여 저장한다.
    - 장애에 대응하는데 필요한 복제본 구현에 유리하다.
        - 보통 블록은 3개의 머신에 복제된다.
        - 손상되면 다른 곳에서 또 복제해와서 복제본 수를 유지한다.

### 3.2.2 네임노드와 데이터노드

- HDFS 클러스터의 마스터-워커 패턴으로 생각하면 되는 개념이 있다.
    - 마스터: 네임노드
        - 파일 시스템의 네임스페이스 관리
        - 파일시스템 트리, 트리에 포함된 파일과 디렉터리의 메타데이터 유지
        - 파일에 속한 모든 블록이 어떤 데이터노드에 존재하는지 파악 (시스템 시작시 데이터노드로부터 전달받는다)
        - 네임노드가 없으면 파일시스템이 멈춘다.
        - 저장된 블록들의 정보를 알수가 없으므로!
    - 워커: 데이터노드
        - 실질적 일꾼
        - 요청이 들어오면 블록을 저장하고 탐색
        - 블록의 목록을 주기적으로 네임노드에 보낸다.
    - HDFS 클라이언트
        - 사용자 대신에 네임노드, 데이터노드 사이에서 통신하는 역할
- 네임노드 장애 극복
    1. 파일시스템의 메타데이터를 파일로 백업하기
    2. secondary namenode 운영
        1. 에디트 로그의 크기를 억제하기 위해 네임스페이스 이미지 + 에디트 로그 → 새로운 네임스페이스로 병합
        2. 네임스페이스 이미지의 복제본 보관
        3. 다만, primary namenode에서 복제될 때 시간이 좀 걸려서 장애가 발생하면 데이터 손실이 어느정도 있다. 

### 3.2.3 블록 캐싱

- 데이터 노드는 디스크에서 저장된 블록을 읽어온다.
    - 자주 접근하는 블록파일은 off-heap의 block cache에 캐싱한다.
    - 기본적으로 블록은 하나의 데이터노드 메모리에만 캐싱
    - 다만, 파일 단위로도 설정할 수 있다.
    - 블록이 캐싱된 위치에서 태스크 실행이 되므로 성능을 높일 수 있다.

### 3.2.4 HDFS 페더레이션

- 네임노드는 모든 정보(모든 파일과 각 블록의 참조 정보)를 **메모리**에서 관리한다.
    - 그래서 파일이 매우 많은 대형 클러스터에서 메모리가 확장에 걸림돌이 된다.
    - 그래서 나온게 HDFS 페더레이션
- 각각의 네임노드가 파일시스템의 네임스페이스 일부를 나누어 관리하도록 설정
    - /user 는 네임노드 1
    - /share 는 네임노드 2
    - 이렇게 나눠서 관리
- 네임스페이스 볼륨: 메타데이터를 구성
    - 서로 독립적이라 네임노드에 장애가 발생해도 서로 영향이 없다.
- 블록 풀: 네임스페이스의 전체 블록 보관
    - 얘는 분리되어 있지 않다.

### 3.2.5 HDFS 고가용성 (HA - High Availability)

- 데이터의 손실을 어떻게 막을까!
    - 네임노드의 메타데이터를 다수의 FS에 복제
    - 보조 네임노드를 사용해 체크포인트 생성
    - 단일 고장점
        - 네임노드가 뻗으면 다 스톱
- 네임노드의 손실은 거의 일어나지 않긴한다.
    - 하지만 HDFS 고가용성을 지원한다.
    - 한쌍의 네임노드를 사용
        - 활성 네임노드
        - 대기 네임노드
        - 활성에 장애가 나면 대기가 요청을 처리
- 대기 네임노드를 활성화 시키는 방법
    - 주키퍼를 이용한다.
    - heartbeat를 사용해 네임노드의 장애를 감시
- graceful failover
    - 관리자가 수동으로 초기화
    - 두개의 네임노드의 역할을 바꾼다.
- ungraceful failover
    - 모르겠어
