# Docker overview
> [https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)

> 한글로 번역하기 애매한 단어들은 그대로 남기고 읽기 전 필요한 지식들은 서두에 기재 했습니다.

도커는 어플리케이션을 개발, shipping, 그리고 실행할때 쓰는 오픈 플랫폼이다. 

도커는 사용자의 어플리케이션을 infrastructure로부터 분리해서 소프트웨어를 빠르게 deliever 할 수 있게 해준다. 

도커를 이용하면, 어플리케이션을 관리하는 방법과 동일하게 infrastructure를 관리할 수 있게 된다. 

코드를 빠르게 shipping, 테스트, 그리고 배포하게 해주는 도커의 방법론적인 이점을 이용한다면, 코드를 작성하고 이를 상품에서 실행시키는 것 사이의 시간 지연을 눈에 띄게 줄일 수 있을것이다.  

# The Docker platform

도커는 '컨테이너'라는 약간은 느슨하게 고립된 환경에서 어플리케이션을 감싸고 실행시키는 기능을 제공한다. 

그 고립성과 보안은 하나의 호스트 위에서 여러개의 컨테이너를 동시에 실행시킬 수 있게 해준다. 

컨테이너는 가볍고, 어플리케이션을 구동하는데 필요한 모든 것들을 담고 있기 때문에, 호스트에 어떤게 설치되어 있는지에 대해서는 고려할 필요가 없다. 

> 호스트랑 분리시켜서 생각하는게 진짜 큰 장점 ㅎㅎ

일을 하다가도 손쉽게 컨테이너를 공유할 수도 있고, 내가 공유해준 사람들이 같은 방식으로 작동하는 똑같은 컨테이너를 받을 것임을 보장할 수 있다.

도커는 컨테이너의 생명주기(lifecycle)을 관리할 수 있는 툴과 플랫폼을 제공한다:

- 컨테이너를 이용해서 어플리케이션과 그걸 지원하는 구성요소들을 개발할 수 있다.
- 컨테이너는 어플리케이션을 배분하고(distributing) 테스트하는 유닛이 된다.
- 준비가 되면, 어플리케이션을 생산 환경에 컨테이너나 orchestrated 형태의 서비스로 배포해보자. 생산 환경이 로컬 데이터 센터(on-premises)이든, 클라우드 제공자든, 혹은 두개의 혼합 형태든 상관 없이 똑같이 적용될것입니다.

# What can I use Docker for?

***어플리케이션의 빠르고, 일관성있는 서비스(delivery)가 가능해진다.***

> CI (Continuous Integration)   
CD (Continuous Delivery)

도커는 개발자들이 로컬 컨테이너를 이용한 표준화된(규격화된) 환경에서 일할 수 있게 함으로써 개발 lifecycle을 능률적으로 바꿔준다. 컨테이너는 CI와 CD 작업 흐름에 아주 좋다. 

다음 예시 시나리오들을 살펴보자:

- 코드를 로컬에서 짜고, 도커 컨테이너를 이용해서 동료 개발자들과 공유한다.
- 도커를 이용해서 어플리케이션을 테스트 환경에 놓고, 자동 혹을 수동 테스트를 실행한다.
- 버그를 찾으면, 개발하는 환경에서 고치고, 테스트와 검증을 위해서 테스트 환경에 재배포한다.
- 테스팅이 끝나면, 고친 제품을 고객들에게 제공하는건 그저 업데이트된 이미지(도커 이미지)를 생산 환경에 push하는 것 만큼 간단하다.

***반응형 배포와 scaling***

> 클라이언트의 사용량에 따라 CPU나 RAM 같은 자원의 할당량을 조절하는 것을 scaling이라고 한다.   
상황에 따라 scaling up, scaling down의 개념이 존재한다.

도커의 컨테이너를 기반으로한 플랫폼은 환경에 제약 없이 포터블한 개발을 제공한다. 도커 컨테이너는 개발자의 로컬 랩탑, 데이터 센터의 물리적 혹은 가상 머신, 클라우드 제공자 위에서, 혹은 언급된 환경들의 하이브리드 환경에서 모두 작동한다. 

도커의 portability와 가벼운 특성은 워크로드를 동적으로 손쉽게 관리할 수 있게 해주어서 거의 실시간으로 사업체가 필요한 만큼 어플리케이션을 scaling up 하거나 축소할 수 있다. 

***하나의 기기에서 더 많은 워크로드 실행하기***

> [Hypervisor](https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor) (하이퍼바이저)란?   
: 가상화의 핵심적인 이점을 이끌어내는 플랫폼. 호스트 머신의 운영체제와 가상 머신들의 리소스를 분리하여 관리한다. 할당된 호스트 머신의 리소스를 여러개의 VM에 부여하는 역할을 한다.

도커는 가볍고 빠르다. 도커는 hypervisor 기반의 VM들에 대해 비용적으로 효율적인 대안이 되기 때문에, 사업적인 목표를 달성함에 있어서 더 많은 컴퓨팅 자원을 사용할 수 있게 해준다. 도커는 적은 자원으로 더 많은 작업을 해야하는 밀도 높은 환경에서 더욱 완벽하게 적용할 수 있다. 

# Docker architecture

도커는 클라이언트-서버 구조를 채택한다. 도커 *클라이언트*는 도커 컨테이너의 빌딩, 실행, 그리고 배포를 하는 도커 *데몬*과 통신한다. 도커 클라이언트와 데몬은 같은 시스템에 존재 *할수도* 있으며, 원격 서버에 위치한 도커 데몬과 도커 클라이언트를 연결하는 방식도 가능하다. 도커 클라이언트와 데몬은 UNIX 소켓이나 네트워크 인터페이스 위의 REST API를 이용해서 통신한다. 또 다른 도커 클라이언트는 도커 Compose로, 여러 개의 컨테이너로 이루어진 어플리케이션과 작업하게 해준다. 

![https://docs.docker.com/engine/images/architecture.svg](https://docs.docker.com/engine/images/architecture.svg)

Src: [https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)

## The Docker daemon

도커 데몬 (`dockerd`) 는 이미지, 컨테이너, 네트워크 그리고 볼륨들 같은 도커 오브젝트들을 관리하기 위해 도커 API 요청을 받는다. 데몬은 도커 서비스를 관리하기 위해서 다른 데몬들과도 통신할 수 있다.  

## The Docker client

도커 클라이언트 (`docker`) 는 많은 도커 사용자들이 도커와 통신하는 주된 방법이다. `docker run` 과 같은 명령어를 사용하게 되면, 클라이언트는 이러한 명령어를 `dockerd` 에게 보낸다. `docker`로 시작하는 명령어는 도커 API를 사용한다. 도커 클라이언트는 하나 이상의 데몬과 통신할수도 있다. 

## Docker registries

도커 레지스트리는 도커 이미지들을 저장한다. 도커 허브는 누구나 사용할 수 있는 public registry이며, 도커는 기본적으로 도커 허브에서 이미지를 찾아보도록 설정되어 있다. 물론 개인의 private registry도 운영할 수 있다. 

`docker pull` 이나  `docker run`같은 명령어를 실행하면, 요청된 이미지를 본인의 설정된 레지스트리에서 가져온다.  `docker push` 명령어는 본인의 이미지를 본인의 설정된 레지스트리에 push하는데 사용된다. 

## Docker objects

도커를 사용하게 되면 이미지, 컨테이너, 네트워크, 볼륨, 플러그인 그리고 다른 오브젝트들을 만들거나 사용하게 된다. 아래는 몇몇 오브젝트들의 간단한 개요들이다. 

### Images

이미지는 도커 컨테이너를 만드는데 필요한 설명과 함께 있는 read-only 템플릿이다. 종종 이미지는 다른 이미지를 기반으로 추가적인 커스텀을 포함한다. 예를 들어서 `ubuntu` 를 기반으로 하며 아파치 웹서버와 본인의 어플리케이션을 설치하는 이미지를 빌드할 수 있다. 

본인만의 이미지를 만들 수도 있으며 다른 사람들이 만들어서 레지스트리에 올려둔 이미지를 사용할 수도 있다. 자신만의 이미지를 만들려면, 이미지를 만들고 실행하는 단계들을 정의한 *Dockerfile*을 만들어야 한다. Dockerfile에 있는 각 명령들은 이미지에서 레이어를 만들게 된다. Dockerfile을 변경하고 이미지를 다시 빌드하게 되면, **변경된 레이어들만 다시 빌드**된다. 이게 바로 다른 가상화 기술들에 비해 이미지를 훨씬 가볍고, 작고 빠르게 만드는 부분이다. 

### Containers

> 내 생각에는 이미지를 클래스, 컨테이너를 객체 이런 개념으로 이해하면 될 것 같다.

컨테이너는 이미지의 실행가능한 인스턴스이다. 도커 API나 CLI를 이용해서 컨테이너를 만들거나,  시작하거나, 멈추거나, 옮기거나 혹은 지울 수 있다. 컨테이너를 하나 이상의 네트워크에 연결할 수 있으며, 스토리지를 붙일 수도 있고, 혹은 현재 상태를 기반으로 새로운 이미지도 만들어낼 수 있다. 

기본적으로, 컨테이너는 상대적으로 다른 컨테이너들과 호스트 머신에서 잘 고립(isolated)되어 있다. 컨테이너의 네트워크, 저장소, 그리고 기반의 subsystem들을 다른 컨테이너와 호스트 머신으로부터 어떻게 고립 시킬지를 제어할 수 있다. 

컨테이너는 이미지로부터 정의되기는 하나, 만들거나 시작할 때 사용자가 설정 옵션 값을 줄 수도 있다. 컨테이너가 삭제되면, pesistent한 저장소(SSD, HDD)에 저장되지 않은 상태 변경 값들은 모두 사라진다. 

### `docker run` 명령어 예시
